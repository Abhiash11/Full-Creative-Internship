Polymorphism
	Polymorphism in Java is a concept by which we can perform a single action in different ways. Polymorphism is derived from 2 Greek words: poly and morphs. The word "poly" means many and "morphs" means forms. So polymorphism means many forms. There are two types of polymorphism in Java: compile-time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding. For example: A person at the same time can have different characteristics. Like a man at the same time is a father, a husband, an employee. So the same person possesses different behaviour in different situations. This is called polymorphism. There are two types of polymorphism: runtime and compile time polymorphism.

Example:
	package week2;
	class Bike{
		void run() {
		System.out.println("running");
	}
	}
	public class Poly1 extends Bike {
		void run() {
		System.out.println("Speed is 70kmph");
	}
		public static void main(String[] args) {
			Bike b= new Poly1(); 				//upcasting
			b.run();
	}
}
Output:
	Speed is 70kmph

Note: If the reference variable of Parent class refers to the object of Child class, it is known as upcasting.

Types of Polymorphism:

   --> Runtime Polymorphism: Runtime polymorphism or Dynamic Polymorphism is a process in which a call to an overridden method is resolved at runtime rather than compile-time. This type of polymorphism is achieved by Method Overriding. Method overriding, on the other hand, occurs when a derived class has a definition for one of the member functions of the base class. That base function is said to be overridden.

Example:
	package week2;
	s Bank{
	float interest() {
	return 0;
	}
}
	class ICICI extends Bank{
	float interest() {
	return 7.1f;
	}
}
	class HDFC extends Bank{
	float interest() {
	return 8.3f;
	}
}
	class AXIS extends Bank{
	float interest() {
	return 7.9f;
	}
}
	public class Polymorphism2 {
		public static void main(String[] args) {
		Bank b;
		b= new ICICI();
		System.out.println("ICICI:\n Rate Of Interest is: "+b.interest());
		b= new HDFC();
		System.out.println("HDFC:\n Rate Of Interest is: "+b.interest());
		b= new AXIS();
		System.out.println("AXIS:\n Rate Of Interest is: "+b.interest());
	}
}

Output:
	ICICI:
	    Rate Of Interest is: 7.1
	HDFC:
	    Rate Of Interest is: 8.3
	AXIS:
	    Rate Of Interest is: 7.9

Example2:
	package week2;
	class Animal{
		void eats() {
		System.out.println("IS eating");
}}
	class Cow extends Animal{
		void eats() {
		System.out.println("is Herbivore");
}}
	class Tiger extends Animal{
		void eats() {
		System.out.println("is Carnivore");
}}
	class Bear extends Animal{
		void eats() {
		System.out.println("is Omnivore");
}}
	public class Poly3 {
		public static void main(String[] args) {
		Animal a;
		a= new Cow();
		a.eats();
		a= new Tiger();
		a.eats();
		a= new Bear();
		a.eats();
}}
Output:
	is Herbivore
	is Carnivore
	is Omnivore

Method Overriding
	If subclass (child class) has the same method as declared in the parent class, it is known as method overriding in Java.  If a subclass provides the specific implementation of the method that has been declared by one of its parent class, it is known as method overriding. It is used to provide a specific and separate implementation of a method which is already provided by its super class and is used in runtime polymorphism. 
Rules for Java Method Overriding
1. The method must have the same name as in the parent class
2. The method must have the same parameter as in the parent class.
3. There must be an IS-A relationship (inheritance).
Note: Static method cannot be overridden because  the static method is bound with class whereas instance method is bound with an object.
Example:
	package week2;
	class Physics{
	void say() {
		System.out.println("This is Physics class");
}}
	class Topic extends Physics{
		void say() {
		System.out.println("Topic is: Reflection");
}}
	public class Polymorphism3 {
		public static void main(String[] args) {
		Physics p= new Physics();
		p.say();
		Topic t= new Topic();
		t.say();
}}
Output:
	This is Physics class
	Topic is: Reflection
In the above example, Physics class, which is the super class,  already had a say(). But the subclass Topic overrides say() to give its own implementation. 

---> Compile time Polymorphism
	Compile-time polymorphism is obtained through method overloading. The term method overloading allows us to have more than one method with the same name but different parameter list. Since this process is executed during compile time, that's why it is known as Compile-Time Polymorphism.
Method Overloading:  If a class has multiple methods having same name but different in parameters, it is known as Method Overloading.  Method overloading increases the readability of the program. 
Example:
	package week2;
	public class MethodOverloading1 {
	void display(int num)
{
	System.out.println("number is: "+num);
}
	void display(int n1, int n2) {
	System.out.println("number 1 is : " + n1 + " \nnumber 2 is : " + n2);
}
	public static void main(String[] args) {
	MethodOverloading1 obj= new MethodOverloading1();
	obj.display(6);
	obj.display(7,3);
}}
In the above example, we implement method overloading by changing several parameters. We have created two methods, display(int num) and display(int n1, int n2 ). In the display(int num) method display, one number and the void display(int n1, int n2 ), displays two numbers. This is the first method of method overloading: by changing the number of arguments.

Another way to perform method overloading is changing the datatypes of arguments. In this example, first method contains two parameters of integer datatype and the second method contains two parameters of double datatype. 
Example:
	package week2;
	public class MethodOverloading2 {
	void Addition(int a, int b) {
	System.out.println(a+b);
}
	void Addition(double a, double b) {
	System.out.println(a+b);
}
	public static void main(String[] args) {
	MethodOverloading2 obj= new MethodOverloading2();
	obj.Addition(1.3, 4.2);
	obj.Addition(6, 8);
}}

Output:
	5.5
	14





